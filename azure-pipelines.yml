  trigger:
    branches:
      include:
        - master

  pr:
    branches:
      exclude:
        - '*'

  name: pr.$(prId)-$(prIteration)

  variables:
  - group: Code_Signing_Certificate_2023_2026
  - name: prId
    value: $[coalesce(variables['System.PullRequest.PullRequestId'], '000')]
  - name: prIteration
    value: $[counter(variables['prId'], 1)]

  stages:
  - stage: BuildAndPublish
    condition: succeeded()
    jobs: 
    - job: BuildAndSign
      pool:
        vmImage: 'windows-latest'

      variables:
        buildConfiguration: 'Release'

      steps:
      - task: UseDotNet@2
        inputs:
          packageType: 'sdk'
          versionSpec: '9.x'

      - checkout: self
        persistCredentials: true
        fetchDepth: 0

      - task: GitVersion@5
        inputs:
          runtime: 'core'
          versionSpec: '5.x'
        name: gitVersion

      - task: DownloadSecureFile@1
        name: cert
        inputs:
          secureFile: 'code-signing-certificate-2023-2026.pfx'

      - script: dotnet restore
        displayName: 'Restore Dependencies'

      # - script: >
      #     dotnet build ./Infragistics.QueryBuilder.Executor.csproj
      #     --configuration $(buildConfiguration)
      #     --no-restore
      #   displayName: 'Build Project'
      
      - powershell: |
          Write-Host "Building project and forcing output path..."
          dotnet build ./Infragistics.QueryBuilder.Executor.csproj `
            --configuration $(buildConfiguration) `
            --no-restore
        displayName: 'Build Project'

      - powershell: |
          $outputDir = "$(Build.SourcesDirectory)\bin\$(buildConfiguration)\net9.0"
          Write-Host "Listing contents of: $outputDir"
          if (-Not (Test-Path $outputDir)) {
            Write-Error "Output folder not found: $outputDir"
            exit 1
          }
          Get-ChildItem $outputDir -Recurse | ForEach-Object {
            Write-Host $_.FullName
          }
        displayName: 'Debug: List build output contents'

      - powershell: |
          $certPath = '$(cert.secureFilePath)'
          $certPassword = '$(SigningCertificatePassword)'
          $dllFolder = "$(Build.SourcesDirectory)\bin\$(buildConfiguration)\net9.0"
          Write-Host "Signing DLLs in folder: $dllFolder"
          if (-Not (Test-Path $dllFolder)) {
              Write-Error "Folder does not exist: $dllFolder"
              exit 1
          }

          $signtoolPath = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
              Where-Object { $_.FullName -match 'x64\\signtool\.exe$' } |
              Select-Object -First 1

          if (-not $signtoolPath) {
              Write-Error "signtool.exe not found in Windows Kits"
              exit 1
          }

          Write-Host "Using signtool at: $($signtoolPath.FullName)"

          $dllFiles = Get-ChildItem -Path $dllFolder -Filter *.dll -Recurse
          foreach ($dll in $dllFiles) {
            Write-Host "Signing $($dll.FullName)..."
            & $signtoolPath.FullName sign /f $certPath /p $certPassword /tr http://timestamp.digicert.com /td sha256 /fd sha256 $dll.FullName

            if ($LASTEXITCODE -ne 0) {
              Write-Error "Signing failed for $($dll.FullName)"
              exit 1
            }
          }
        displayName: 'Sign all DLL files with PFX certificate'

      - powershell: |
          $dllFolder = "$(Build.SourcesDirectory)\bin\$(buildConfiguration)\net9.0"
          Write-Host "Checking if DLLs in $dllFolder are signed..."

          $signtool = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
            Where-Object { $_.FullName -match 'x64\\signtool\.exe$' } |
            Select-Object -First 1

          if (-not $signtool) {
            Write-Error "signtool.exe not found under Windows Kits"
            exit 1
          }

          Write-Host "Using signtool: $($signtool.FullName)"

          Get-ChildItem $dllFolder -Filter *.dll -Recurse | ForEach-Object {
            Write-Host "Verifying: $($_.FullName)"
            & $signtool.FullName verify /pa $_.FullName
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Signature verification failed for $($_.FullName)"
              exit 1
            }
          }
        displayName: 'Verify DLL Signatures'

      - powershell: |
          $certPath = '$(cert.secureFilePath)'
          $certPassword = '$(SigningCertificatePassword)'
          $packageOutputDir = "$(Build.ArtifactStagingDirectory)\nuget"
          $packageVersion = "$(GitVersion.NuGetVersionV2)"

          Write-Host "Packing project from existing build output..."
          dotnet pack ./Infragistics.QueryBuilder.Executor.csproj `
            --no-build `
            --configuration $(buildConfiguration) `
            -p:PackageVersion=$packageVersion `
            -o $packageOutputDir

          if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet pack failed"
            exit 1
          } 
        displayName: 'Pack NuGet Package using PowerShell'

      - task: PublishBuildArtifacts@1
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)/nuget'
          ArtifactName: 'NuGetPackage'
          publishLocation: 'Container'
        displayName: 'Publish nuget Package as Build Artifact'

      # - task: NuGetCommand@2
      #   inputs:
      #     command: 'push'
      #     packagesToPush: '$(Build.ArtifactStagingDirectory)/nuget/*.nupkg'
      #     nuGetFeedType: 'external'
      #     publishFeedCredentials: 'NuGet.org API Key'
      #   displayName: 'Publish to NuGet.org'
